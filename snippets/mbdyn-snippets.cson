'.source.mbdyn.section.data':
  'problem-definition':
    'prefix': 'problem:'
    'body': 'problem: ${1:\\{initial value | inverse dynamics\\}};'
    'description': 'Problem type'
'.source.mbdyn.section.initialvalue':
  'initial-time':
    'prefix': 'initial time:'
    'body': 'initial time: ${1:<time>};'
    'description': 'Simulation initial time'
  'final-time':
    'prefix': 'final time:'
    'body': 'final time: ${1:\\{forever | <time>\\}};'
    'description': 'Simulation final time'
  'strategy':
    'prefix': 'strategy:'
    'body': 'strategy: ${1:<strategy_type>}'
    'description': 'Strategy for time step change'
  'min-time-step':
    'prefix': 'min time step:'
    'body': 'min time step: ${1:<min_time_step>};'
    'description': 'Minimum allowed time step'
  'max-time-step':
    'prefix': 'max time step:'
    'body': 'max time step: ${1:\\{<max_time_step> | unlimited\\}};'
    'description': 'Maximum allowed time step'
  'time-step':
    'prefix': 'time step:'
    'body': 'time step: ${1:<time_step>};'
    'description': 'Initial time step. If no change is asked, constant throughout simulation'
  'modify-residual test':
    'prefix': 'modify residual test;'
    'body': 'modify residual test;'
    'description': 'Modify residual test taking in account the status rate of change'
  'tolerance':
    'prefix': 'tolerance'
    'body': """
      tolerance: ${1:\\{null | <residual_tolerance>\\}},
        ${2:[test, \\{none | norm | minmax\\}] [, scale]}'
        ${3:[, \\{null | <solution_tolerance>\\}]}
        ${4:[, test, \\{none | norm | minmax\\}];}
    """
    'description': 'Residual and (optional) solution tolerance'
  'max iterations':
    'prefix': 'max iterations'
    'body': 'max iteraions: ${1:<max_iterations>} ${2:[, at most]};'
    'description': 'Error out after <max_iterations> or continue after at most <max_iterations> if error is reduced'
  'modify residual test':
    'prefix': 'modify residual test'
    'body': 'modify resisual test;'
    'description': 'Modify the residual test taking into account the rate of change of the status'
  'method':
    'prefix': 'method'
    'body': 'method: ${1:<method_data>};'
    'description': 'Selection of integration scheme'
  'crank nicolson':
    'prefix': 'crank nicolson'
    'body': 'crank nicolson;'
    'descrition': 'Crank-Nicolson multistep method'
  'ms':
    'prefix': 'ms'
    'body': """
      ms,
      ${1:(DriveCaller)<differential_radius>},
      ${2:[(DriveCaller)<algebraic_radius>]};
    """
    'description': 'Multistep method.'
'.source.mbdyn.definition.strategy':
  'strategy-factor':
    'prefix': 'factor:'
    'body': """
      factor,
      ${1:<reduction_factor>},
      ${2:<steps_before_reduction>},
      ${3:<raise_factor>},
      ${4:<steps_before_raise>},
      ${5:<min_iterations>,}
      ${6:[<max_iterations]};
    """
    'description': 'Strategy for time step change: use factor'
  'strategy-change':
    'prefix': 'change'
    'body': 'change, ${1:(DriveCaller)<time_step_pattern>};'
    'description': 'Strategy for time step change: use drive caller'
  'strategy-no-change':
    'prefix': 'no change'
    'body': 'no change;;'
    'description': 'Strategy for time step change: no change. WARNING: this
    disables termination of max iterations'
# '.source.mbdyn.section.inversedynamics':
'.source.mbdyn.section.nodes':
  'node-structural-definition':
    'prefix': 'structural:'
    'body': 'structural: ${1:<label>}, ${2:\\{static | dynamic | modal | dummy\\}}'
    'description': 'Structural node definition'
  'node-structural-dynamic-definition':
    'prefix': 'dynamic'
    'body': """
      dynamic,
      ${1:<absolute_position>,}
      ${2:<absolute_orientation_matrix>,}
      ${3:[orientation description, <orientation_description>],}
      ${4:<absolute_velocity>,}
      ${5:<absolute_angular_velocity>;}
    """
    'description': 'Dynamic structural node definition'
  'node-structural-static-definition':
    'prefix': 'static'
    'body': """
      static,
      ${1:<absolute_position>,}
      ${2:<absolute_orientation_matrix>,}
      ${3:[orientation description, <orientation_description>],}
      ${4:<absolute_velocity>,}
      ${5:<absolute_angular_velocity>};
    """
    'description': 'Static (inertia-less) structural node definition'
  'node-structural-static-displacement-definition':
    'prefix': 'static displacement'
    'body': """
      static displacement,
      ${1:<absolute_position>,}
      ${2:<absolute_velocity>;}
    """
    'description': 'Static displacement (massless point) structural node definition'
  'node-structural-dynamic-displacement-definition':
    'prefix': 'dispdyn'
    'body': """
      dynamic displacement,
      ${1:<absolute_position>,}
      ${2:<absolute_velocity>;}
    """
    'description': 'Dynamic displacement (point mass) structural node definition'
  'node-structural-modal-definition':
    'prefix': 'modal'
    'body': """
      modal,
      ${3:<absolute_position>,}
      ${4:<absolute_orientation_matrix>,}
      ${6:<absolute_velocity>,}
      ${7:<absolute_angular_velocity>;}
    """
    'description': 'Modal structural node definition'
  'node-structural-dummy-definition':
    'prefix': 'dummy'
    'body': 'dummy, ${1:<base node label>,}, ${2:\\{offset | relative frame\\}}'
    'description': 'Dummy structural node definition'
  'node-structural-dummy-offset-definition':
    'prefix': 'offset'
    'body': """
      offset,
        ${1:<relative_offset>,}
        ${2:<relative_orientation_matrix>;}
    """
    'description': 'Dummy node (offset) definition'
  'node-structural-dummy-relframe-definition':
    'prefix': 'relative frame'
    'body': """
      relative frame,
          ${1:<reference_node_label>,}
            position, ${2:<reference_offset>,}
            orientation, ${3:<reference_orientation_matrix>},
          pivot node, ${4:<pivot_node_label>,}
            position, ${5:<pivot_offset>,}
            orientation, ${6:<pivot_orientation_matrix>;}
    """
    'description': 'Dummy node (relative frame) definition'
  'node-structural-assembly':
    'prefix': 'assembly'
    'body': """
      assembly,
        ${1:<position_initial_stiffness>},
        ${2:<velocity_initial_stiffness>},
        ${3:<omega_rotates>}, {4:\\{yes | no\\};}
    """
    'description': 'Assembly-related parameters of structural node'
  'node-electic-definition':
    'prefix': 'electric'
    'body': """
      electric: ${1:<label>},
        value, ${2:<initial_value>},
        derivative, ${3:<derivative_initial_value>;}
    """
    'description': 'Electric node definition'
  'node-abstract-definition':
    'prefix': 'abstract'
    'body': """
      abstract: ${1:<label>}, ${2:\\{algebraic | differential\\},}
        value, ${3:<initial_value>},
        derivative, ${4:<derivative_initial_value>;}
    """
    'description': 'Abstract node definition'
  'node-hydraulic-definition':
    'prefix': 'hydraulic'
    'body': """
      'hyraulic: ${1:<label>},
        value, ${2:<initial_value>;}'
    """
    'description': 'Hydraulic node definition'
  'node-parameter-definition':
    'prefix': 'parameter'
    'body': 'parameter: ${1:<label>}, value, ${2:<initial_value>,} ${3:\\{element | sample and hold | beam strain gage\\},}'
    'description': 'Parameter node definition (WARNING: parameter nodes are obsolete)'
  'node-parameter-sampleandhold-definition':
    'prefix': 'sample and hold'
    'body': 'sample and hold, ${1:<signal>}, ${2:<sample_time>};'
    'description': 'Parameter node (sample and hold) definition'
  'node-parameter-beamstraingage-definition':
    'prefix': 'beam strain gage'
    'body': 'beam strain gage, ${1:<y>}, ${2:<z>};'
    'description': 'Parameter node (beam strain gage) definition.'
  'node-output-global':
    'prefix': 'output:'
    'body': 'output: ${1:\\{structural | abstract | electric | hydraulic | parameter\\}, };'
    'description': 'Node output card'
'.source.mbdyn.section.nodes.output':
  'output-structural-nodes-global':
    'prefix': 'structural,'
    'body': 'structural, ${1:[accelerations,]} ${2:\\{<node_label> | range\\}}'
    'description': 'Structural nodes output control'
  'output-electric-nodes-global':
    'prefix': 'electric,'
    'body': 'electric, ${1:\\{<node_label> | range\\}}'
    'description': 'Electric nodes output control'
  'output-abstract-nodes-global':
    'prefix': 'abstract,'
    'body': 'abstract, ${1:\\{<node_label> | range\\}}'
    'description': 'Abstract nodes output control'
  'output-hydraulic-nodes-global':
    'prefix': 'hydraulic,'
    'body': 'hydraulic, ${1:\\{<node_label> | range\\}}'
    'description': 'Hydraulic nodes output control'
  'output-nodes-global-range':
    'prefix': 'range'
    'body': 'range, ${1:<node_start_label>}, ${2:<node_end_label>}'
'.source.mbdyn.section.drivers':
  'file-driver':
    'prefix': 'file:'
    'body': 'file: ${2:\\{fixed step | variable step | socket | RTAI input | stream\\}}'
    'description': 'File driver definition'
  'fixed-step-driver':
    'prefix': 'fixed step'
    'body': """
      fixed step,
        ${1:\\{count | <steps_number>\\}},
        ${2:<columns_number>},
        initial time, ${3:\\{from file | <initial_time\\}},
        time step, ${4:\\{from file | <time_step>\\}},
        ${4:[interpolation, {linear | const}],}
        ${5:[pad zeroes, {yes | no}
          bailout, \\{none | upper | lower | any\\}],}
        "${6:<file_name>}";
    """
    'description': 'Fixed step file driver definition'
  'variable-step-driver':
    'prefix': 'variable step'
    'body': """
      variable step,
        ${1:<channels_number>},
        ${2:[interpolation, \\{linear | const\\}],}
        ${3:[pad zeroes, \\{yes | no\\}
          bailout, \\{none | upper | lower | any\\}],}
        "${4:<file_name>}";
    """
    'description': 'Variable step file driver definition'
  'socket-driver':
    'prefix': 'socket'
    'body': """
      socket,
        ${1:<columns_number>},
        ${2:[initial values, <value #1>, ...],}
        ${3:\\{local, "<file_name"> | [port, <port_number>, ] (AuthenticationMethod) <authentication>\\}};
    """
    'description': 'Socket file driver definition'
  'RTAI-mailbox-driver':
    'prefix': 'RTAI input'
    'body': """
      RTAI input,
        stream driver name, "${1:<stream_name>}",
          ${2:[create, {yes | no}],}
          ${3:[host, "<host_name>"],}
          ${4:[\\{[non] blocking, [...]\\}],}
          ${5:<columns_number>};
    """
    'description': 'RTAI mailbox driver definition'
  'stream-driver':
    'prefix': 'stream'
    'body': """
      stream,
        name, ${1:"<stream_name>"},
        create, ${2:\\{yes | no\\}},
        ${3:[{local, "<path>" | [port, <port_number>, ] [host, "<host_name>" , ]}],}
        ${4:[ \\{ [no] signal | [non] blocking \\} , [...] ,]}
        ${5:[input every, <steps>,]}
        ${6:[receive first, {yes | no},]}
        ${7:[timeout, <timeout>],}
        ${8: [echo, "<echo_file_name>",]}
          ${9: [precision, <precision>,]}
          ${9: [shift, <shift>,]}
        ${10:<columns_number>}
        ${11:[, initial values, <value #1>, ... ,]}
        ;
    """
    'description': 'Stream driver definition'
'.source.mbdyn.section.elements':
  'aerodynamic-body':
    'prefix': 'aerodynamic-body:'
    'body': """
      aerodynamic body: ${1:<label>},
      ${2:<node_label>},
      ${3:[ [user defined] induced velocity, <induced_velocity_label> [, passive] ,]}
      ${4:(Vec3)<relative_surface_offset>},
      ${5:(OrientationMatrix)<relative_surface_orientation>},
      ${6:(real)<surface_span>},
      ${7:(Shape<1D>)<surface_chord>},
      ${8:(Shape<1D>)<surface_aerodynamic_center>},
      ${9:(Shape<1D>)<surface_b_c_point>},
      ${10:(Shape<1D>)<surface_twist>},
      ${11:[tip loss, (Shape<1D>)<tip_loss>],}
      ${12:<integration_points>}
      ${13:[, control, (DriveCaller)<control_drive>]}
      ${14:[, \\{naca 0012 | rae 9671 | [theodorsen, ] | c81, <c81_data>]}
      ${15:[, unsteady, { bielawa }]}
      ${16:[, jacobian, \\{yes | no | <bool> \\}]}
      ${17:[, <custom_output>]}
      ${18:[\\{std | gauss | node \\}]}
      ;
    """
    'description': 'Aerodynamic body element definition'
  'aerodynamic-beam2':
    'prefix': 'aerodynamic-beam2:'
    'body': """
      aerodynamic beam2: ${1:<label>},
      ${2:<beam2_label>},
      ${3:[ [user defined] induced velocity, <induced_velocity_label> [, passive] ,]}
      ${4:(Vec3)<relative_surface_offset_1>},
      ${5:(OrientationMatrix)<relative_surface_orientation_1>},
      ${6:(Vec3)<relative_surface_offset_2>},
      ${7:(OrientationMatrix)<relative_surface_orientation_2>},
      ${8:(Shape<1D>)<surface_chord>},
      ${9:(Shape<1D>)<surface_aerodynamic_center>},
      ${10:(Shape<1D>)<surface_b_c_point>},
      ${11:(Shape<1D>)<surface_twist>},
      ${12:[tip loss, (Shape<1D>)<tip_loss>],}
      ${13:<integration_points>}
      ${14:[, control, (DriveCaller)<control_drive>]}
      ${15:[, \\{naca 0012 | rae 9671 | [theodorsen, ] | c81, <c81_data>]}
      ${16:[, unsteady, { bielawa }]}
      ${17:[, jacobian, \\{yes | no | <bool> \\}]}
      ${18:[, <custom_output>]}
      ${19:[\\{std | gauss | node \\}]}
      ;
    """
    'description': 'Aerodynamic beam2 element definition'
  'aerodynamic-beam3':
    'prefix': 'aerodynamic-beam3:'
    'body': """
      aerodynamic beam3: ${1:<label>},
      ${2:<beam3_label>},
      ${3:[ [user defined] induced velocity, <induced_velocity_label> [, passive] ,]}
      ${4:(Vec3)<relative_surface_offset_1>},
      ${5:(OrientationMatrix)<relative_surface_orientation_1>},
      ${6:(Vec3)<relative_surface_offset_2>},
      ${7:(OrientationMatrix)<relative_surface_orientation_2>},
      ${8:(Vec3)<relative_surface_offset_2>},
      ${9:(OrientationMatrix)<relative_surface_orientation_2>},
      ${10:(Shape<1D>)<surface_chord>},
      ${11:(Shape<1D>)<surface_aerodynamic_center>},
      ${12:(Shape<1D>)<surface_b_c_point>},
      ${13:(Shape<1D>)<surface_twist>},
      ${14:[tip loss, (Shape<1D>)<tip_loss>],}
      ${15:<integration_points>}
      ${16:[, control, (DriveCaller)<control_drive>]}
      ${17:[, \\{naca 0012 | rae 9671 | [theodorsen, ] | c81, <c81_data>]}
      ${18:[, unsteady, { bielawa }]}
      ${19:[, jacobian, \\{yes | no | <bool> \\}]}
      ${20:[, <custom_output>]}
      ${21:[\\{std | gauss | node \\}]}
      ;
    """
    'description': 'Aerodynamic beam3 element definition'
  'aeromodal':
    'prefix': 'aeromodal:'
    'body': """
      aeromodal: ${1:<label>},
        ${2:<reference_modal_joint>},
        ${3:<(OrientationMatrix)<orientation>},
        ${4:<reference_chord>},
        ${5:<number_of_aerodynamic_states>},
        ${6:[rigid, ]}
        ${7:[gust, ]}
        ${8:"<modal_matrices_file>"};
    """
    'description': 'Aeromodal element definition'
  'aircraft-instruments':
    'prefix': 'aircraft instruments:'
    'body': """
      aircraft instruments: ${1:<label>},
        ${2:<aircraft_node>}
        ${3:[, orientation, \\{flight mechanics | aeroelasticity | (OrientationMatrix) <relative_orientation_matrix>\\}]};
    """
    'description': 'Aircraft instruments element definition'
  'air-properties':
    'prefix': 'air properties:'
    'body': """
      air properties: ${1:<label>},
      ${2:\\{(DriveCaller) <air_density>, (real) <sound_celerity>
        | std, \\{ \\{ SI | British \\}
               [, temperature variation, (real)<delta_T>]
               | (real)<p0>, (DriveCaller)<rho0> ,
                 (real)<T0>, (real)<dT/dz>, (real)<R>, (real)<g0>, (real)<z1>, (real)<z2>\\}
        [, reference altitude, (real)<z0> ] \\} },
      ${3:(TplDriveCaller<Vec3>)<air_speed>}
      ${4:[, gust, <gust_model> [, ...]]};
    """
    'description': 'Air properties definition'
  'generic-aerodynamic-force':
    'prefix': 'generic aerodynamic force:'
    'body': """
      generic aerodynamic force: ${1:<label>},
        ${2:[position, (Vec3)<relative_position>, ]}
        ${3:[orientation, (OrientationMatrix)<relative_orientation>, ]}
        ${4:[reference surface, (real)<reference_surface>, ]}
        ${5:[reference length, (real)<reference_length>, ]}
        ${6:[alpha first, \\{ no | yes \\}, ]}
        ${7:\\{file, <data_file_specification> | reference, <gaf_data_label>\\}};
    """
    'description': 'Generic aerodynamic force definition (WARNING: Does not contribute to Jacobian!)'
  'induced-velocity':
    'prefix': 'induced velocity:'
    'body': """
      induced velocity: ${1:<label>},
        ${2:<induced_velocity_type>, <induced_velocity_data>}
        ;
    """
    'description': 'Induced velocity element definition.'
  'automatic-structural':
    'prefix': 'automatic structural:'
    'body': """
      automatic structural: ${1:<label>},
        ${2:(Vec3)<momentum>},
        ${3:(Vec3)<momenta_moment>},
        ${4:(Vec3)<momentum_derivative>},
        ${5:(Vec3)<momenta_moment_derivative>};
    """
    'description': 'Automatic structural element. Used to improve convergence in derivatives phase. WARNING: <momenta_moment> and <momenta_moment_derivative> make sense only for 6DOF structural nodes'
  'beam3':
    'prefix': 'beam3:'
    'body':"""
      beam3: ${1:<label>},
        ${2:<node_1_label>},
          position, ${3:(Vec3)<relative_offset_1>},
          orientation, ${4:(OrientationMatrix)<relative_orientation_1>},
        ${5:<node_2_label>},
          position, ${6:(Vec3)<relative_offset_2>},
          orientation, ${7:(OrientationMatrix)<relative_orientation_2>},
        ${8:<node_3_label>},
          position, ${9:(Vec3)<relative_offset_3>},
          orientation, ${10:(OrientationMatrix)<relative_orientation_3>},
        ${11:\\{(OrientationMatrix)<orientation_matrix_section_I> | from nodes \\}},
        ${12:(ConstitutiveLaw<6D>)<constitutive_law_section_I>},
        ${13:\\{same | (OrientationMatrix)<orientation_matrix_section_II> | from nodes \\}},
        ${14:\\{same | (ConstitutiveLaw<6D>)<constitutive_law_section_II>\\}},
        ${15:[, piezoelectric actuator, [...] ]}
        ${16:[, custom_output]};
    """
    'description': 'beam3 element definition'
  'beam2':
    'prefix': 'beam2:'
    'body': """
      beam2: ${1:<label>},
        ${2:<node_1_label>},
          position, ${3:(Vec3)<relative_offset_1>},
          orientation, ${4:(OrientationMatrix)<relative_orientation_1>},
        ${5:<node_2_label>},
          position, ${6:(Vec3)<relative_offset_2>},
          orientation, ${7:(OrientationMatrix)<relative_orientation_2>},
        ${8:\\{(OrientationMatrix)<orientation_matrix_section_I> | from nodes \\}},
        ${9:(ConstitutiveLaw<6D>)<constitutive_law_section_I>},
        ${10:[, piezoelectric actuator, [...] ]}
        ${11:[, custom_output]};
    """
    'description': 'beam2 element definition'
  'body-element':
    'prefix': 'body:'
    'body': """
      body: ${1:<label>}, ${2:<node_label>}
        ${3:\\{
            <one_body>
            | <one_pointmass>
            | variable mass, <one_vm_body>
            | condense, <num_masses>, \\{ <one_body | <one_pointmass> \\}, [, ...]
        \\}}
    """
    'description': 'Body element definition'
  'bulk':
    'prefix': 'bulk:'
    'body': """
      bulk: ${1:<label>},
        stiffness spring,
          ${2:(NodeDof)<dof>},
          ${3:(DriveCaller)<stiffness_drive>};
    """
    'description': 'Bulk element definition'
  'electric':
    'prefix': 'electric:'
    'body': """
      electric: ${1:<label>},
        ${2:<electric_type>, <electric_arglist>}
        ;
    """
    'description': 'Electric element definition'
  'stream-output':
    'prefix': 'stream output:'
    'body': """
      stream output: ${1:<label>},
        stream name, ${2:"<stream_name>"},
        create, ${3:\\{yes | no\\}},
        ${4:[\\{local, "<socket_name>", | [port, <port_number>, ] host, "<host_name>", \\}]}
        ${5:[\\{ [no] signal | [non] blocking | [no] send first | [do not] abort if broken\\}] [, ...] ,}
        ${6:[output every, <steps>, ]}
        ${7:[echo, <file_name> [, precision, <precision>] [, shift, <shift>] ,]}
        ${8:<content>};
    """
    'description': 'Stream output element definition'
'.source.mbdyn.section.elements.airprops':
  'gust-model-front-1D':
    'prefix': 'front 1D'
    'body': """
      front 1D,
        ${1:(Vec3), <front_direction>},
        ${2:(Vec3), <perturbation_directio>},
        ${3:(real), <front_velocity>},
        ${4:(DriveCaller), <front_profile>}
    """
    'description': 'Front 1D gust model definition'
  'gust-model-scalar-function':
    'prefix': 'scalar function'
    'body': """
      scalar function,
        ${1:reference position, (Vec3)<X0>},
        ${2:reference orientation, (OrientationMatrix)<R0>},
        ${3:(ScalarFunction), <sf>}
    """
    'description': 'Scalar function gust model definition'
  'gust-model-power-law':
    'prefix': 'power law'
    'body': """
      power law,
        ${1:reference position, (Vec3)<X0>},
        ${2:reference orientation, (OrientationMatrix)<R0>},
        ${3:reference elevation, (real)<z_ref>},
        ${4:reference velocity, (DriveCaller)<v_ref>},
        ${5:exponend, (real)<exponent>};
    """
    'description': 'Power law wind profile gust model definition'
  'gust-model-logarithmic':
    'prefix': 'logarithmic'
    'body': """
      logarithmic,
        ${1:reference position, (Vec3)<X0>},
        ${2:reference orientation, (OrientationMatrix)<R0>},
        ${3:reference elevation, (real)<z_ref>},
        ${4:reference velocity, (DriveCaller)<v_ref>},
        ${5:surface roughness length, (real)<z_0>}
    """
    'description': 'Logarithmic wind profile gust model definition'
'.source.mbdyn.section.elements.aero':
  'aerodynamic-elements-c81-data':
    'prefix': 'c81'
    'body': """
      c81,
        ${1:\\{<c81_label> | multiple, [...] | interpolated, [...]\\}};
    """
    'description': 'c81 airfoil data definition'
  'aerodynamic-elements-c81-data-multiple':
    'prefix': 'multiple'
    'body': 'multiple, <airfoil_number>, <c81_label>, <end_point>, [, ...]'
    'description': 'c81 airfoil data definition. Type: multiple.'
  'aerodynamic-elements-c81-data-interpolates':
    'prefix': 'interpolated'
    'body': 'interplolated, <airfoil_number>, <c81_label>, <position>, [, ...]'
    'description': 'c81 airfoil data definition. Type: interpolated.'
'.source.mbdyn.section.elements.beam3':
  'piezoelectric-actuator':
    'prefix': 'piezoelectric actuator'
    'body': """
      piezoelectric actuator,
        ${1:(integer)<electrodes_number>},
        ${2:<abstract_node_label_list>},
        ${3:(Mat6xN)<piezoelectric_matrix_I>},
        ${4:\\{same | (Mat6xN)<piezoelectric_matrix_II>\\} }
    """
    'description': 'piezoelectric actuator (beam3 element) definition'
'.source.mbdyn.section.elements.beam2':
  'piezoelectric-actuator':
    'prefix': 'piezoelectric actuator'
    'body': """
      piezoelectric actuator,
        ${1:(integer)<electrodes_number>},
        ${2:<abstract_node_label_list>},
        ${3:(Mat6xN)<piezoelectric_matrix_I>}
    """
    'description': 'piezoelectric actuator (beam2 element) definition'
'.source.mbdyn.section.elements.body':
  'body-one-body':
    'prefix': 'one_body'
    'body': """
      ${1:(real)<mass>},
        ${2:(Vec3)<relative_center_of_mass>},
      ${3:(Mat3x3)<inertia_matrix>}
        ${4:[, inertial, \\{node | (OrientationMatrix)<orientation_matrix>\\} ]};
    """
    'description': 'One body (rigid, constant mass) definition.'
  'body-one-pointmass':
    'prefix': 'one_pointmass'
    'body': """
      ${1:(real)<mass>};
    """
    'description': 'One pointmass (rigid body, constant mass) definition. WARNING: the node has to be a displacement node.'
  'body-one-vm-body':
    'prefix': 'one_vm_body'
    'body': """
      ${1:(DriveCaller)<mass>},
      ${2:(TplDriveCaller<Vec3>)<relative_center_of_mass>},
      ${3:(TplDriveCaller<Mat3x3>)<variable_mass_inertia_matrix>},
      ${4:(TplDriveCaller<Mat3x3>)<variable_geometry_inertia_matrix>};
    """
    'description': 'One body (rigid body, variable mass) definition.'
'.source.mbdyn.section.elements.genaeroforce':
  'data-file-specification':
    'prefix': 'file'
    'body': """
      file,
        ${1:[\\{ angle units, \\{ radians | degrees \\}
              | scale angles, (real)<scale_angle_factor> \\}, ]}
        ${2:[scale lengths, (real)<length_scale_factor> , ]}
        ${3: "<data_file_name>"}
    """
    'description': "Data file specification for generic aerodynamic force"
'.source.mbdyn.section.elements.inducedvel':
  'rotor':
    'prefix': 'rotor'
    'body': """
      rotor,
        ${1:<craft_node>},
        ${2:[orientation, (OrientationMatrix)<rotor_orientation>, ]}
        ${3:<rotor_node>},
        induced velocity, ${4:\\{ no | uniform | glauert [, type, <glauert_type>] | mangler | dynamic inflow \\} },
        ${4:(real)<reference_omega>}, ${5:(real)<reference_radius>}
        ${5:[, <option>, [, ...] ]}
    """
    'description': 'Induced velocity element definition. Type: rotor (helicopter).'
  'inflow-dynamic-inflow':
    'prefix': 'dynamic inflow'
    'body': """
      dynamic inflow,
        ${1:(real)<reference_omega>},
        ${2:(real)<reference_radius>},
        ${3:[, option, [, ...]]}
    """
    'description': 'Dynamic inflow induced velocity model'
  'inflow-option-ground':
    'prefix': 'ground'
    'body': 'ground, ${1:<ground_node>}'
    'description': 'Ground node definition in inflow model: informs the rotor about ground proximity'
  'inflow-option-delay':
    'prefix': 'delay'
    'body': 'delay, ${1:(DriveCaller)<memory_factor>}'
    'description': 'Memory factor definition in inflow model. Together with hover_correction_factor and ff_correction_factor are used to correct nominal induced velocity'
  'inflow-option-max-iterations':
    'prefix': 'max iterations'
    'body': 'max iterations, ${1:(integer)<max_iterations>}'
    'description': 'Max iterations to compute nominal induced velocity'
  'inflow-option-eta':
    'prefix': 'eta'
    'body': 'eta, ${1:(real)<eta>}'
    'description': 'Fraction of the difference betwee two iterations of the nominal induced velocity actually used in computation. Defaults to 1.'
  'inflow-option-tolerance':
    'prefix': 'tolerance',
    'body': 'tolerance, ${1:(real)<tolerance>}'
    'description': 'Tolerance factor definition in inflow model'
  'inflow-option-corretion':
    'prefix': 'correction'
    'body': 'correction, ${1:(real)<hover_correction_factor>}, ${2:(real)<ff_correction_factor>}'
    'description': 'Hover and forward flight correction factors. Together with memory_factor are used to correct nominal induced velocity.'
  'inflow-option-initial-value':
    'prefix': 'initial value'
    'body': 'initial value, ${1:(real)<const_vel>}, ${2:(real)<cosine_vel>}, ${3:(real)<sine_vel>}'
    'description': 'Initialization of dynamic inflow induced velocity model'
'.source.mbdyn.section.elements.electric':
  'electric-accelerometer':
    'prefix': 'accelerometer'
    'body': """
      accelerometer,
        ${1:<struct_node_label>},
        ${2:<abstract_node_label>},
        ${3:(Vec3)<measure_direction>},
        ${4:(real)<omega>},
        ${5:(real)<tau>},
        ${6:(real)<csi>},
        ${7:(real)<kappa>}
    """
    'description': 'Accelerometer electric element definition. NOTE: A legacy version, with built-in transfer function, is available. See section 8.7 of input manual.'
  'electric-displacement':
    'prefix': 'displacement'
    'body': """
      displacement,
        ${1:<struct_node_1_label>}, ${2:(Vec3)<relative_offset_1>},
        ${3:<struct_node_2_label>}, ${4:(Vec3)<relative_offset_2>},
        ${5:<abstract_node_label>}
    """
    'description': 'Electric displacement element'
  'electric-motor':
    'prefix': 'motor'
    'body': """
      motor,
        ${1:<struct_node_1_label>},
        ${2:<struct_node_2_label>},
        ${3:(Vec3)<direction_relative_to_node_1>},
        ${4:<abstract_node_1_label},
        ${5:<abstract_node_2_label},
        ${6:(real)<dG>},
        ${7:(real)<dL>},
        ${8:(real)<dR>}
    """
    'description': 'Electric motor element definition'
  'electric-discete-control':
    'prefix': 'discete control'
    'body': """
      discrete control,
        ${1:(integer)<num_outputs>}, ${2:(integer)<num_inputs>},
        ${3:(integer)<order_A>} ${4:[, fir, (integer)<order_B>]},
        ${5:(integer)<num_iter>},
        ${6:<control_data>},
        outputs,
          ${7:(ScalarValue)<output_value>}
            ${8:[, scale, (DriveCaller)<scale>]}
          ${9:[, ...]}
        inputs,
          ${10:(NodeDof)<input_dof>}
          ${11:[, ...]}
          ;
    """
    'description': 'Discrete control electric element definition.'
'.source.mbdyn.section.elements.electric.dcontrol':
  'electric-discete-control-control':
    'prefix': 'control'
    'body': 'control, ${1:"<control_matrices_file>"},'
    'description': 'Control data for discrete control element definition'
  'electric-discete-control-identification':
    'prefix': 'identification'
    'body': """
      identification,
        ${1:\\{ arx | armax \\} }
        ${2:[, forgettingfactor,
                  \\{
                      const, (real)<d>
                      | dynamic, (real)<n1>, (real)<n2>, (real)<rho>, (real)<fact>, (real)<kref>, (real)<klim>
                  \\}] }
        ${3:[, excitation, (DriveCaller)<excitation_drive> [, ...]]}
        ${4:[, file, "<output_file_name>"]},
    """
    'description': 'Identification data for discrete control element definition'
  'electric-discete-control-adaptive':
    'prefix': 'adaptive control'
    'body': """
      adaptive control,
        ${1:[\\{arx | armax \\} , ]}
        ${2:[periodic, <periodic_factor>, ]}
        ${3:\\{gpc, <gpc_args> | deadbeat <deadbeat_args> \\}}
        ${4:[, forgettingfactor,
                  \\{
                      const, (real)<d>
                      | dynamic, (real)<n1>, (real)<n2>, (real)<rho>, (real)<fact>, (real)<kref>, (real)<klim>
                  \\}] }
        ${5:[, excitation, (DriveCaller)<excitation_drive> [, ...]]}
        ${6:[, trigger, (DriveCaller)<trigger_drive>]}
        ${7:[, desired output, (DriveCaller)<output_drive>, [, ...]]}
        ${8:[, file, "<file_name>"]},
    """
    'description': 'Adaptative discrete control definition'
  'electric-discete-control-adaptive-gpc':
    'prefix': 'gpc'
    'body': """
      gpc,
        ${1:(integer)<periodic_advancing_horizon>},
        ${2:(integer)<control_advancing_horizon>},
        ${3:[prediction weights, (real)<Wi>, [, ...], ]}
        ${4:[control weights, (real)<Ri>, [, ...], ]}
        ${5:(DriveCaller)<weight_drive>}
    """
    'description': 'GPC Adaptive discrete control definition'
  'electric-discete-control-adaptive-deadbeat':
      'prefix': 'deadbeat'
      'body': """
        deadbeat,
          ${1:(integer)<periodic_advancing_horizon>},
          ${2:(integer)<control_advancing_horizon>}
      """
      'description': 'Deadbeat Adaptive discrete control definition'
'.source.mbdyn.section.elements.streamoutput':
  'stream-output-values':
    'prefix': 'values'
    'body': """
      values,
          ${1:<channel_number>},
            ${2:\\{[nodedof, ] (NodeDof) <output_dof> | drive, (DriveCaller) <drive_data> \\}, [...]}
    """
    'description': 'Stream output content of type values'
  'stream-output-motion':
    'prefix': 'motion'
    'body': """
      motion,
        ${1:[output flags,
          \\{ position
            | orientation matrix
            | orientation matrix transpose
            | velocity
            | angular velocity
            [, ... ] , ]}
        ${2: \\{all | <struct_node_label>, [, ...] \\}}
    """
    'description': 'Stream output content of type motion'
